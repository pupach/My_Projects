# Variant

В данный задаче вам предстоит реализовать свой аналог класса ```std::variant```

```std::variant<TS...>``` - класс, который хранит все указанные типы на одной памяти

Вам нужно реализовать:
- Конструкторы:
    - Default
    - Конструктор копирования
    - Конструктор перемещения
    - Конструктор от произвольного типа, который можно положить в данный variant
- Операторы присваивания:
    - Копирующий
    - Перемещающий
    - От произвольного типа, который можно положить в данный variant
- Функция get:
    - ```get<T>(variant)``` - Возвращает ссылку на объект типа T, если он активный в данный момент, иначе кидает исключение. Если типа T нет в variant - не компилируется
    - ```get<I>(variant)``` - возвращает ссылку на объект I-го типа из пачки TS..., если он активный. иначе кидает такое же исключение. Если индекс слишком большой - не компилируется
- Функция ```holds_alternative<T>(variant)``` - возвращает true, если тип T активный в variant, иначе false
- Функция ```visit(func, variants...)``` - вызывает callable func с аргументами - реально хранящимися типами в variant, подставляя значения из variants... слева направо
- Деструктор

Для дополнительной справки смотри:
https://en.cppreference.com/w/cpp/utility/variant