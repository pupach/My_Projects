# JSON

В данной задаче вам предстоит реализовать функцию
```
template <typename T>
ConvertToJson(const T& value);
```

Данная функция принимает объект и конвертирует его в формат json

Вам нужно поддержать следующие типы:
- ```int``` - выдает строковое представление
- ```double``` - выдает строковое представление (о точности можно не думать)
- ```std::string```
- ```bool``` - переводит в строковое ```true``` или ```false```
- ```enum``` - переводит значение enum в строковое представление
- ```vector``` - собирает массив json (пример ```std::vector<int>{1, 2, 3}``` -> [1, 2, 3])
- ```tuple``` - собирает массив json (пример ```std::tuple{1, true, 2.2}``` -> [1, true, 2.2])
- ```variant``` - переводит в json текущий активный тип в variant
- ```optional``` - переводит в json значение в optional, если оно есть, иначе убирает его из json (вместе с ключом)
- ```map<std::string, T>``` - строит словарь json, где ключи - string, а значение - любой тип из предложенных в задании
- ```unordered_map<std::string, T>``` - аналогично
- произвольный POD тип - строит словарь json, где ключи - имена полей, а значения - json полученный из значения поля. Гарантируются структуры не более чем на 15 полей

Заметьте, что в json строки должны быть обернуты в ""

Тесты массивов будут убирать из полученных json пробелы

Тесты map и структур будут производиться при помощи утилиты jq, поэтому поля/ключи словарей можно выводить в произвольном порядке

Будет хорошим бонусом, если вы так же поддержите:
- enum class
- произвольный sequence контейнер
- произвольный tuple-like тип
- произвольную обертку над объектом, совпадающую по интерфейсу с std::optional
- произвольное key value storage, где key - convertible_to<std::string>
- еслм имя ключа начинается на _ - его не должно быть в json
- поддержать произвольное количество полей в структуре (не факт, что это возможно)

Удачи
